# 定时心跳线程精度测试

本项目针对不同的定时心跳实现方案进行精度测试，特别是在系统负载升高时的表现。

## 项目背景

在高可靠的系统中，定时心跳是一种常见的健康检测机制。但在系统负载升高时，由于CPU调度延迟，心跳可能会被延迟触发甚至丢失。本项目实现并对比了3种不同的定时心跳实现方案，测试它们在不同负载情况下的性能表现。

## 实现方案

项目实现了3种心跳机制：

1. **基于条件变量和绝对时间戳** - 使用`std::condition_variable::wait_until`在指定的绝对时间点唤醒线程
2. **基于timerfd + epoll** - 利用Linux内核提供的timerfd和epoll机制实现高精度定时器（仅Linux平台支持）
3. **基于sleep_for** - 使用`std::this_thread::sleep_for`简单循环实现

## 测试方法

项目测试在以下三种负载场景下的心跳精度：

1. **低负载场景** - 系统空闲状态
2. **高负载场景** - 通过`stress -c`工具模拟CPU密集型负载
3. **混合负载场景** - 同时运行CPU和I/O密集型负载

每种场景下，程序会：
- 计算每次心跳的实际间隔与预期间隔的偏差
- 统计偏差的平均值、最大值、标准差和百分位数（P95/P99）

## 使用方法

### 直接编译运行

```bash
# 编译项目
make

# 低负载测试
make test-low

# 高负载测试（需要安装stress工具）
make test-high

# 混合负载测试（需要安装stress工具）
make test-mixed
```

### 使用Docker环境测试

```bash
# 构建Docker镜像
make docker-build

# 低负载测试
make docker-test-low

# 高负载测试
make docker-test-high

# 混合负载测试
make docker-test-mixed
```

### 参数配置

通过命令行参数可以配置测试：

```bash
./build/bin/heartbeat_demo [心跳间隔(毫秒)] [测试时长(秒)]
```

## 测试结果分析

### 不同心跳实现机制的优缺点

1. **条件变量 + 绝对时间戳**
   - 优点：标准C++实现，跨平台
   - 缺点：在高负载下可能出现较大偏差

2. **timerfd + epoll** (仅Linux平台)
   - 优点：利用内核定时器，精度通常最好
   - 缺点：非跨平台，仅Linux支持

3. **sleep_for**
   - 优点：实现简单
   - 缺点：精度最差，容易受系统负载影响

## 测试报告

测试显示，在不同负载下，三种实现方案表现有明显差异：

1. 在**低负载**条件下：三种方案都能较好地保持心跳精度
2. 在**高负载**条件下：timerfd方案的偏差通常最小
3. 在**混合负载**条件下：sleep_for方案的偏差最大

详细测试数据请查看统计报告。